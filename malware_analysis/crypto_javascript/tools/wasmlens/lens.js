#!/usr/bin/env node
/**
 * WASMLens Tracer - modular version
 *
 * Traces JavaScript and WASM activity on a given URL using Puppeteer and Chromium.
 */

const zlib = require("zlib");
const path = require("path");
const fs = require("fs");
const fsp = require("fs").promises;
const puppeteer = require("puppeteer");
const yargs = require("yargs");
const { hideBin } = require("yargs/helpers");

const argv = yargs(hideBin(process.argv))
  .option("url", {
    type: "string",
    demandOption: true,
    description: "The URL to trace",
  })
  .option("ssl-ignore-errors", {
    type: "boolean",
    default: false,
    description: "Ignore HTTPS certificate errors",
  })
  .option("deep", {
    type: "boolean",
    default: false,
    description: "Enable deep tracing",
  })
  .option("timeout", {
    type: "number",
    default: 15,
    description: "Seconds to wait after page load before ending trace",
  })
  .option("categories", {
    type: "string",
    description: "Additional comma-separated tracing categories to append",
  })
  .option("out", {
    type: "string",
    default: "traces",
    description: "Output folder base",
  })
  .option("chrome", {
    type: "string",
    description: "Path to Chromium/Chrome executable to use",
  })
  .option("local", {
    type: "boolean",
    description: "Treat localhost as secure and ignore SSL errors",
  })
  .help()
  .parseSync();

/**
 * Build Chromium launch arguments.
 */
function makeChromiumArgs(localTreat = false) {
  const base = [
    "--disable-background-timer-throttling",
    "--disable-ipc-flooding-protection",
    "--disable-renderer-backgrounding",
    // "--disable-setuid-sandbox",
    "--disable-web-security",
    "--enable-automation",
    "--enable-blink-features=FeaturePolicyOldSyntax,OffscreenCanvas",
    "--enable-blink-features=IdleDetection,OffscreenCanvas",
    "--enable-experimental-web-platform-features",
    "--enable-experimental-web-platform-features",
    "--enable-gpu-benchmarking",
    "--enable-logging=stderr",
    "--enable-memory-info",
    "--enable-precise-memory-info",
    "--enable-webassembly",
    "--expose-wasm",
    "--experimental-wasm-return-call",
    "--experimental-wasm-simd",
    "--js-flags=--expose-gc",
    "--js-flags=--trace-gc --trace-turbo --interpreted-frames-native-stack",
    //"--no-sandbox",
    "--print-bytecode",
    "--print-wasm-bytecode",
    "--print-wasm-code",
    "--print-wasm-stub-code",
    "--trace-wasm",
    "--trace-wasm-memory",
    "--v=1",
    "--wasm-trace-memory",
    "--wasm-trace-serialization",
  ];
  if (localTreat) {
    base.push("--ignore-certificate-errors");
    base.push("--unsafely-treat-insecure-origin-as-secure=http://localhost");
    base.push("--unsafely-treat-insecure-origin-as-secure=https://localhost");
  }
  return base;
}

/**
 * Build tracing categories string.
 */
function buildCategories(deep) {
  const base = [
    "devtools.timeline",
    "v8",
    "blink.user_timing",
    "blink.console",
    "net",
    "v8.wasm",
    "v8.execute",
    "disabled-by-default-devtools.timeline",
    "blob",
    "netlog",
    "native",
    "loading",
    "blink",
    "blink.resource",
    "blink.feature_usage",
    "blink.scheduler",
    "renderer.scheduler",
    "toplevel",
    "blink.module_instantiation",
    "blink.net",
  ];
  if (deep) {
    base.push(
      "disabled-by-default-blink.console",
      "disabled-by-default-blink.feature_usage",
      "disabled-by-default-blink.gc",
      "disabled-by-default-blink.module_instantiation",
      "disabled-by-default-blink.net",
      "disabled-by-default-blink.performance",
      "disabled-by-default-blink.resource_usage",
      "disabled-by-default-blink.scheduler",
      "disabled-by-default-blink.worker",
      "disabled-by-default-devtools.screenshot",
      "disabled-by-default-devtools.timeline.frame",
      "disabled-by-default-devtools.timeline.stack",
      "disabled-by-default-embedded_worker",
      "disabled-by-default-memory-infra",
      "disabled-by-default-memory-infra.cpu_profiler",
      "disabled-by-default-memory.infra",
      "disabled-by-default-v8",
      "disabled-by-default-v8.console",
      "disabled-by-default-v8.cpu_profiler",
      "disabled-by-default-v8.cpu_profiler.hires",
      "disabled-by-default-v8.gc",
      "disabled-by-default-v8.heap_stats",
      "disabled-by-default-v8.idle_deopt_stats",
      "disabled-by-default-v8.runtime",
      "disabled-by-default-v8.runtime_stats",
      "disabled-by-default-v8.wasm",
      "disabled-by-default-v8.wasm.detailed",
      "disabled-by-default-v8.wasm.turbofan"
    );
  }
  if (argv.categories) {
    const extra = String(argv.categories)
      .split(",")
      .map((s) => s.trim())
      .filter(Boolean);
    base.push(...extra);
  }
  return Array.from(new Set(base)).join(",");
}

/**
 * Prepare output directories and return their paths.
 */
async function prepareOutputDirs(baseOut) {
  const ts = new Date().toISOString().replace(/[:.]/g, "-");
  const outDir = `${baseOut}/${ts}`;
  const turboDir = `${outDir}/turbo`;
  await fsp.mkdir(outDir, { recursive: true }).catch(() => {});
  await fsp.mkdir(turboDir, { recursive: true }).catch(() => {});
  return {
    outDir,
    turboDir,
    jsonPath: `${outDir}/trace.json`,
    gzPath: `${outDir}/trace.json.gz`,
  };
}

/**
 * Inject WASM logging and interception scripts into the page.
 */
async function injectWasmLogging(page) {
  // Patch URL.createObjectURL (no-op)
  await page.evaluateOnNewDocument(() => {
    (function () {
      try {
        const orig = URL.createObjectURL;
        URL.createObjectURL = function (obj) {
          try {
            /* no-op */
          } catch (e) {}
          return orig.apply(this, arguments);
        };
      } catch (e) {}
    })();
  });

  // Patch WASM exports to log calls
  await page.evaluateOnNewDocument(() => {
    function wrapExports(exports, moduleName) {
      const wrapped = {};
      for (const key of Object.keys(exports)) {
        const val = exports[key];
        if (typeof val === "function") {
          wrapped[key] = function (...args) {
            const result = val.apply(this, args);
            console.log(
              `[wasmlens] [${moduleName}] ${key}(${JSON.stringify(
                args
              )}) => ${JSON.stringify(result)}`
            );
            return result;
          };
        } else {
          wrapped[key] = val;
        }
      }
      return wrapped;
    }
    // Patch instantiate
    const origInstantiate = WebAssembly.instantiate;
    WebAssembly.instantiate = async function (bufferSource, importObject) {
      const res = await origInstantiate.apply(this, arguments);
      if (res && res.instance && res.instance.exports) {
        res.instance.exports = wrapExports(res.instance.exports, "instantiate");
      }
      return res;
    };
    // Patch instantiateStreaming
    const origInstantiateStreaming = WebAssembly.instantiateStreaming;
    WebAssembly.instantiateStreaming = async function (source, importObject) {
      const res = await origInstantiateStreaming.apply(this, arguments);
      if (res && res.instance && res.instance.exports) {
        res.instance.exports = wrapExports(
          res.instance.exports,
          "instantiateStreaming"
        );
      }
      return res;
    };
  });

  // Patch WASM instantiate to log input/output
  await page.evaluateOnNewDocument(() => {
    (function () {
      function wrapExports(exports, moduleName) {
        const wrapped = {};
        for (const key of Object.keys(exports)) {
          const val = exports[key];
          if (typeof val === "function") {
            wrapped[key] = function (...args) {
              const result = val.apply(this, args);
              try {
                console.log(
                  `[wasmlens] [${moduleName}] call: ${key}(${JSON.stringify(
                    args
                  )}) => ${JSON.stringify(result)}`
                );
              } catch {}
              return result;
            };
          } else {
            wrapped[key] = val;
          }
        }
        return wrapped;
      }
      // Patch instantiate
      const origInstantiate = WebAssembly.instantiate;
      WebAssembly.instantiate = async function (bufferSource, importObject) {
        const res = await origInstantiate.apply(this, arguments);
        if (res && res.instance && res.instance.exports) {
          res.instance.exports = wrapExports(
            res.instance.exports,
            "instantiate"
          );
        }
        return res;
      };
      // Patch instantiateStreaming
      const origInstantiateStreaming = WebAssembly.instantiateStreaming;
      WebAssembly.instantiateStreaming = async function (source, importObject) {
        const res = await origInstantiateStreaming.apply(this, arguments);
        if (res && res.instance && res.instance.exports) {
          res.instance.exports = wrapExports(
            res.instance.exports,
            "instantiateStreaming"
          );
        }
        return res;
      };
    })();
  });
}

/**
 * Listen for WASM logs from the page and save them.
 */
function setupWasmConsoleLog(page) {
  page.on("console", (msg) => {
    if (msg.text().startsWith("[wasmlens]")) {
      fs.appendFileSync("wasm_calls.txt", msg.text() + "\n");
    }
  });
}

/**
 * Start tracing with the given categories.
 */
async function startTracing(client, categories) {
  await client.send("Tracing.start", {
    transferMode: "ReturnAsStream",
    categories,
    options: "record-as-much-as-possible,enable-sampling",
  });
}

/**
 * Collect trace data from the browser and return as Buffer.
 */
async function collectTraceData(client, handle) {
  const jsonChunks = [];
  let jsonBytes = 0;
  let eof = false;
  while (!eof) {
    try {
      const res = await client.send("IO.read", { handle, size: 64 * 1024 });
      const dataBuf = res.base64Encoded
        ? Buffer.from(res.data, "base64")
        : Buffer.from(res.data || "", "utf8");
      jsonChunks.push(dataBuf);
      jsonBytes += dataBuf.length;
      eof = res.eof === true;
    } catch (e) {
      console.error("IO.read error", e);
      break;
    }
  }
  try {
    await client.send("IO.close", { handle });
  } catch (e) {
    /* ignore */
  }
  return Buffer.concat(jsonChunks);
}

/**
 * Move turbo-*.json/cfg files to the turboDir.
 */
function moveTurboFiles(turboDir) {
  try {
    const cwdFiles = fs.readdirSync(process.cwd());
    for (const f of cwdFiles) {
      if (/^turbo-.*\.json$/i.test(f) || /^turbo-.*\.cfg$/i.test(f)) {
        const src = path.join(process.cwd(), f);
        const dst = path.join(turboDir, f);
        try {
          fs.renameSync(src, dst);
        } catch (e) {
          console.error("Move turbo failed", e);
        }
      }
    }
  } catch (e) {
    /* ignore */
  }
}

/**
 * Main tracing logic.
 */
async function main() {
  const { url, deep, out } = argv;
  const { outDir, turboDir, jsonPath, gzPath } = await prepareOutputDirs(
    String(out).replace(/\/+$/, "")
  );
  console.error("Output directory:", outDir);

  const originalCwd = process.cwd();

  // Determine "local" mode
  const positionalLocal = Array.isArray(argv._) && argv._.includes("local");
  const localMode = Boolean(argv.local) || positionalLocal;

  console.info(
    "Creating browser with args:",
    makeChromiumArgs(localMode).join(" ")
  );

  const userChromium = "/Applications/Chromium.app/Contents/MacOS/Chromium";
  const chromeArg = argv.chrome;
  let execPath = chromeArg || userChromium;

  if (localMode) {
    process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";
  }

  let browser;
  try {
    const ignoreHTTPSErrors = Boolean(argv["ssl-ignore-errors"]) || localMode;
    const args = makeChromiumArgs(localMode);
    const launchOpts = { headless: false, args, ignoreHTTPSErrors };
    if (execPath) launchOpts.executablePath = execPath;
    browser = await puppeteer.launch(launchOpts);
    if (browser.process && typeof browser.process === "function") {
      const browserProcess = browser.process();
      if (browserProcess && browserProcess.stderr) {
        const wasmLogStream = fs.createWriteStream("chromium_wasm_stderr.log", {
          flags: "a",
        });
        browserProcess.stderr.on("data", (chunk) => {
          wasmLogStream.write(chunk);
          // opzionale: anche su console
          process.stderr.write(chunk);
        });
        console.log(
          "Chromium stderr will be saved to chromium_wasm_stderr.log"
        );
      }
    }
  } catch (launchErr) {
    console.error("puppeteer.launch failed:", launchErr);
    throw launchErr;
  }

  console.log("Browser launched");

  try {
    const page = await browser.newPage();
    console.log("New page created");
    if (localMode) {
      try {
        await page.setBypassCSP(true);
      } catch {}
    } else if (argv.ssl) {
      try {
        await page.setBypassCSP(true);
      } catch {}
    }
    const client = await page.target().createCDPSession();
    // Start V8 CPU profiler
    try {
      await client.send("Profiler.enable");
      await client.send("Profiler.start");
      console.info("Profiler started");
    } catch (e) {
      console.warn("Profiler start failed:", e && e.message ? e.message : e);
    }

    const categories = buildCategories(Boolean(deep));
    await injectWasmLogging(page);
    setupWasmConsoleLog(page);

    await startTracing(client, categories);

    // Resolve local file paths
    let navigateUrl = url;
    try {
      const maybe = String(url);
      if (!/^https?:\/\//i.test(maybe) && !maybe.startsWith("file://")) {
        const abs = path.resolve(maybe);
        try {
          await fsp.stat(abs);
          navigateUrl = "file://" + abs;
        } catch {
          /* not found */
        }
      }
    } catch (e) {}

    console.log("Navigating to url...", navigateUrl);
    await page
      .goto(navigateUrl, { waitUntil: "load", timeout: 60000 })
      .catch(() => null);

    const timeoutSec = Number(argv.timeout || 9);
    const waitMs = Math.max(0, Math.floor(timeoutSec * 1000));
    console.log(`Waiting ${waitMs}ms after load to capture activity`);
    await new Promise((r) => setTimeout(r, waitMs));

    // Ending tracing...
    try {
      await client.send("Tracing.end");
    } catch (e) {
      console.error("Tracing.end error", e);
    }

    const tracingComplete = await Promise.race([
      new Promise((resolve) => {
        client.once("Tracing.tracingComplete", (event) => {
          console.error("Tracing.tracingComplete event");
          resolve(event);
        });
      }),
      new Promise((resolve) => setTimeout(() => resolve(null), 15000)),
    ]);

    if (!tracingComplete) {
      console.warn(
        "No Tracing.tracingComplete received within timeout — proceeding to finalize files"
      );
    }

    const handle =
      tracingComplete && tracingComplete.stream ? tracingComplete.stream : null;
    let jsonBytes = 0,
      gzipBytes = 0;

    if (handle) {
      const all = await collectTraceData(client, handle);
      await fsp
        .writeFile(jsonPath, all)
        .catch((e) => console.error("Failed writing json file", e));
      jsonBytes = all.length;
      try {
        const gzBuf = zlib.gzipSync(all, {
          level: zlib.constants.Z_BEST_SPEED,
        });
        await fsp
          .writeFile(gzPath, gzBuf)
          .catch((e) => console.error("Failed writing gzip file", e));
        gzipBytes = gzBuf.length;
      } catch (e) {
        console.error("Failed creating gzip from json buffer", e);
      }
    } else {
      console.error("No trace stream handle, skipping IO.read loop");
    }

    // Stop Profiler and write .cpuprofile
    try {
      const { profile } = await client.send("Profiler.stop");
      const cpuprofilePath = path.join(outDir, "trace.cpuprofile");
      await fsp.writeFile(cpuprofilePath, JSON.stringify(profile));
      console.info("Wrote CPU profile to", cpuprofilePath);
    } catch (e) {
      console.warn(
        "Profiler stop/save failed:",
        e && e.message ? e.message : e
      );
    }

    console.info("Wrote bytes:", { jsonBytes, gzipBytes });
    console.log("Wrote raw trace and gzip");

    moveTurboFiles(turboDir);
  } finally {
    try {
      await browser.close();
    } catch {}
    try {
      process.chdir(originalCwd);
    } catch {}
  }
}

main().catch((e) => {
  console.error(e);
  process.exit(2);
});
