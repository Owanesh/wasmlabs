#!/usr/bin/env node
/**
 * WASMLens Tracer - modular version with console log redirection
 *
 * Traces JavaScript and WASM activity on a given URL using Puppeteer and Chromium.
 * Includes efficient console log redirection to logs.txt file.
 */

const zlib = require("zlib");
const path = require("path");
const fs = require("fs");
const fsp = require("fs").promises;
const puppeteer = require("puppeteer");
const yargs = require("yargs");
const { hideBin } = require("yargs/helpers");

const argv = yargs(hideBin(process.argv))
  .option("url", {
    type: "string",
    demandOption: true,
    description: "The URL to trace",
  })
  .option("ssl-ignore-errors", {
    type: "boolean",
    default: false,
    description: "Ignore HTTPS certificate errors",
  })
  .option("deep", {
    type: "boolean",
    default: false,
    description: "Enable deep tracing",
  })
  .option("timeout", {
    type: "number",
    description: "Seconds to wait after page load before ending trace",
  })
  .option("categories", {
    type: "string",
    description: "Additional comma-separated tracing categories to append",
  })
  .option("out", {
    type: "string",
    default: "traces",
    description: "Output folder base",
  })
  .option("chrome", {
    type: "string",
    description: "Path to Chromium/Chrome executable to use",
  })
  .option("local", {
    type: "boolean",
    description: "Treat localhost as secure and ignore SSL errors",
  })
  .option("turbo", {
    type: "boolean",
    default: false,
    description: "Enable turbo tracing and move turbo-* files to turbo/ folder",
  })
  .option("stdio", {
    type: "boolean",
    default: false,
    description: "Redirect stdout and stderr to files",
  })
  .help()
  .parseSync();

/**
 * Build Chromium launch arguments.
 */
function makeChromiumArgs(localTreat = false) {
  const base = [
    "--disable-background-timer-throttling",
    "--disable-ipc-flooding-protection",
    "--disable-renderer-backgrounding",
    // "--disable-setuid-sandbox",
    "--disable-web-security",
    "--enable-automation",
    "--enable-blink-features=FeaturePolicyOldSyntax,OffscreenCanvas",
    "--enable-blink-features=IdleDetection,OffscreenCanvas",
    "--enable-experimental-web-platform-features",
    "--enable-experimental-web-platform-features",
    "--enable-gpu-benchmarking",
    // Silent Chromium - disable all console output
    "--disable-logging",
    "--log-level=3",
    "--silent",
    "--no-default-browser-check",
    "--no-first-run",
    "--disable-default-apps",
    "--disable-popup-blocking",
    "--disable-prompt-on-repost",
    "--disable-hang-monitor",
    "--disable-background-networking",
    "--enable-memory-info",
    "--enable-precise-memory-info",
    "--enable-webassembly",
    "--expose-wasm",
    "--experimental-wasm-return-call",
    "--experimental-wasm-simd",
    "--js-flags=--expose-gc",
    "--js-flags=--trace-gc --trace-turbo --interpreted-frames-native-stack",
    //"--no-sandbox",
    "--print-bytecode",
    "--print-wasm-bytecode",
    "--print-wasm-code",
    "--print-wasm-stub-code",
    "--trace-wasm",
    "--trace-wasm-memory",
    "--wasm-trace-memory",
    "--wasm-trace-serialization",
  ];
  if (localTreat) {
    base.push("--ignore-certificate-errors");
    base.push("--unsafely-treat-insecure-origin-as-secure=http://localhost");
    base.push("--unsafely-treat-insecure-origin-as-secure=https://localhost");
  }
  return base;
}

/**
 * Build tracing categories string.
 */
function buildCategories(deep) {
  const base = [
    "devtools.timeline",
    "v8",
    "blink.user_timing",
    "blink.console",
    "net",
    "v8.wasm",
    "v8.execute",
    "disabled-by-default-devtools.timeline",
    "blob",
    "netlog",
    "native",
    "loading",
    "blink",
    "blink.resource",
    "blink.feature_usage",
    "blink.scheduler",
    "renderer.scheduler",
    "toplevel",
    "blink.module_instantiation",
    "blink.net",
  ];
  if (deep) {
    base.push(
      "disabled-by-default-blink.console",
      "disabled-by-default-blink.feature_usage",
      "disabled-by-default-blink.gc",
      "disabled-by-default-blink.module_instantiation",
      "disabled-by-default-blink.net",
      "disabled-by-default-blink.performance",
      "disabled-by-default-blink.resource_usage",
      "disabled-by-default-blink.scheduler",
      "disabled-by-default-blink.worker",
      "disabled-by-default-devtools.screenshot",
      "disabled-by-default-devtools.timeline.frame",
      "disabled-by-default-devtools.timeline.stack",
      "disabled-by-default-embedded_worker",
      "disabled-by-default-memory-infra",
      "disabled-by-default-memory-infra.cpu_profiler",
      "disabled-by-default-memory.infra",
      "disabled-by-default-v8",
      "disabled-by-default-v8.console",
      "disabled-by-default-v8.cpu_profiler",
      "disabled-by-default-v8.cpu_profiler.hires",
      "disabled-by-default-v8.gc",
      "disabled-by-default-v8.heap_stats",
      "disabled-by-default-v8.idle_deopt_stats",
      "disabled-by-default-v8.runtime",
      "disabled-by-default-v8.runtime_stats",
      "disabled-by-default-v8.wasm",
      "disabled-by-default-v8.wasm.detailed",
      "disabled-by-default-v8.wasm.turbofan"
    );
  }
  if (argv.categories) {
    const extra = String(argv.categories)
      .split(",")
      .map((s) => s.trim())
      .filter(Boolean);
    base.push(...extra);
  }
  return Array.from(new Set(base)).join(",");
}

/**
 * Prepare output directories and return their paths.
 */
async function prepareOutputDirs(baseOut, turboEnabled) {
  const ts = new Date().toISOString().replace(/[:.]/g, "-");
  const outDir = `${baseOut}/${ts}`;
  const turboDir = turboEnabled ? `${outDir}/turbo` : null;
  await fsp.mkdir(outDir, { recursive: true }).catch(() => {});
  if (turboEnabled)
    await fsp.mkdir(turboDir, { recursive: true }).catch(() => {});
  return {
    outDir,
    turboDir,
    jsonPath: `${outDir}/trace.json`,
    gzPath: `${outDir}/trace.json.gz`,
    stdout: `${outDir}/stdout.txt`,
    stderr: `${outDir}/stderr.txt`,
  };
}

/**
 * Start tracing with the given categories.
 */
async function startTracing(client, categories) {
  await client.send("Tracing.start", {
    transferMode: "ReturnAsStream",
    categories,
    options: "record-as-much-as-possible,enable-sampling",
  });
}

/**
 * Collect trace data from the browser and return as Buffer.
 */
async function collectTraceData(client, handle) {
  let eof = false;
  let chunks = [];
  while (!eof) {
    const res = await client.send("IO.read", { handle, size: 64 * 1024 });
    let chunk = res.base64Encoded
      ? Buffer.from(res.data, "base64")
      : Buffer.from(res.data, "utf8");
    if (chunk.length > 0) chunks.push(chunk);
    eof = res.eof === true;
  }
  await client.send("IO.close", { handle });
  return Buffer.concat(chunks);
}

/**
 * Move turbo-*.json/cfg files to the turboDir.
 */
function moveTurboFiles(turboDir) {
  if (!turboDir) return;
  try {
    const cwdFiles = fs.readdirSync(process.cwd());
    for (const f of cwdFiles) {
      if (/^turbo-.*\.json$/i.test(f) || /^turbo-.*\.cfg$/i.test(f)) {
        const src = path.join(process.cwd(), f);
        const dst = path.join(turboDir, f);
        try {
          fs.renameSync(src, dst);
        } catch (e) {
          console.error("Move turbo failed", e);
        }
      }
    }
  } catch (e) {
    /* ignore */
  }
}

/**
 * Setup advanced console and error logging to file with buffering and timestamps.
 */
function setupAdvancedConsoleLog(page, stdoutPath, stderrPath, enable) {
  if (!enable) return { closeStreams: (cb) => cb && cb() };
  // Separate streams for stdout/stderr if needed
  const stdoutStream = fs.createWriteStream(stdoutPath, {
    flags: "a",
    encoding: "utf8",
    highWaterMark: 64 * 1024,
  });
  const stderrStream = fs.createWriteStream(stderrPath, {
    flags: "a",
    encoding: "utf8",
    highWaterMark: 64 * 1024,
  });

  stdoutStream.on("error", (err) => {
    console.error("Stdout stream error:", err);
  });
  stderrStream.on("error", (err) => {
    console.error("Stderr stream error:", err);
  });

  // Listen to all console messages
  page.on("console", (msg) => {
    const args = msg.args().map((arg) => {
      try {
        return arg.toString();
      } catch {
        return "[Non-serializable]";
      }
    });
    const logLine = ` ${args.join(" ")}\n`;

    // Route log types to stdout/stderr
    if (msg.type() === "error" || msg.type() === "warning") {
      stderrStream.write(logLine);
    } else {
      stdoutStream.write(logLine);
    }
  });

  // Listen to page errors
  page.on("pageerror", (err) => {
    const logLine = `${new Date().toISOString()} [pageerror] ${err.toString()}\n`;
    stderrStream.write(logLine);
  });

  // Graceful shutdown
  function closeStreams(cb) {
    let pending = 3;
    function done() {
      if (--pending === 0 && cb) cb();
    }
    stdoutStream.end(done);
    stderrStream.end(done);
  }

  return { stdoutStream, stderrStream, closeStreams };
}

/**
 * Main tracing logic.
 */
async function main() {
  const { url, deep, out, turbo, stdio } = argv;
  const { outDir, turboDir, jsonPath, gzPath, stdout, stderr } =
    await prepareOutputDirs(String(out).replace(/\/+$/, ""), turbo);
  console.error("Output directory:", outDir);

  const originalCwd = process.cwd();

  // Determine "local" mode
  const positionalLocal = Array.isArray(argv._) && argv._.includes("local");
  const localMode = Boolean(argv.local) || positionalLocal;

  console.info(
    "Creating browser with args:",
    makeChromiumArgs(localMode).join(" ")
  );

  const userChromium = "/Applications/Chromium.app/Contents/MacOS/Chromium";
  const chromeArg = argv.chrome;
  let execPath = chromeArg || userChromium;

  if (localMode) {
    process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";
  }

  let browser;
  let client;
  let page;
  let closeStreams;
  let sigintReceived = false;
  let tracingEnded = false;
  let endTracingResolve;
  let endTracingPromise = new Promise((resolve) => {
    endTracingResolve = resolve;
  });

  // Handler to gracefully end tracing on ENTER
  async function handleEnter() {
    if (sigintReceived) {
      console.warn("Signal already received, please wait...");
      return;
    }
    sigintReceived = true;
    try {
      if (client && !tracingEnded) {
        tracingEnded = true;
        await client.send("Tracing.end");
      }
    } catch (e) {
      console.error("Errore su Tracing.end:", e);
    }
    endTracingResolve();
  }

  // Rimuovi SIGINT, ascolta INVIO
  process.removeAllListeners("SIGINT");
  process.stdin.setEncoding("utf8");
  process.stdin.resume();
  console.info("Press ENTER to stop tracing and write trace.json");
  process.stdin.once("data", async () => {
    await handleEnter();
  });

  try {
    const ignoreHTTPSErrors = Boolean(argv["ssl-ignore-errors"]) || localMode;
    const args = makeChromiumArgs(localMode);
    const launchOpts = {
      headless: "new",
      args,
      ignoreHTTPSErrors,
      dumpio: false,
    };
    if (execPath) launchOpts.executablePath = execPath;
    browser = await puppeteer.launch(launchOpts);

    console.log("Browser launched");

    page = await browser.newPage();
    console.log("New page created");

    // Advanced console logging (page JS logs/errors)
    ({ closeStreams } = setupAdvancedConsoleLog(page, stdout, stderr, stdio));

    if (localMode) {
      try {
        await page.setBypassCSP(true);
      } catch {}
    } else if (argv.ssl) {
      try {
        await page.setBypassCSP(true);
      } catch {}
    }

    client = await page.target().createCDPSession();

    // Start V8 CPU profiler
    try {
      await client.send("Profiler.enable");
      await client.send("Profiler.start");
      console.info("Profiler started");
    } catch (e) {
      console.warn("Profiler start failed:", e && e.message ? e.message : e);
    }

    const categories = buildCategories(Boolean(deep));

    await startTracing(client, categories);

    // Resolve local file paths
    let navigateUrl = url;
    try {
      const maybe = String(url);
      if (!/^https?:\/\//i.test(maybe) && !maybe.startsWith("file://")) {
        const abs = path.resolve(maybe);
        try {
          await fsp.stat(abs);
          navigateUrl = "file://" + abs;
        } catch {
          /* not found */
        }
      }
    } catch (e) {}

    console.log("Navigating to url...", navigateUrl);
    await page
      .goto(navigateUrl, { waitUntil: "load", timeout: 60000 })
      .catch(() => null);

    // Tracing logic (timeout o Ctrl+C)
    if (typeof argv.timeout === "number") {
      const timeoutSec = argv.timeout;
      const waitMs = Math.max(0, Math.floor(timeoutSec * 1000));
      console.log(
        `Waiting ${waitMs}ms after load to capture activity (including console logs)`
      );
      await new Promise((r) => setTimeout(r, waitMs));
      tracingEnded = true;
      try {
        await client.send("Tracing.end");
      } catch (e) {
        console.error("Tracing.end error", e);
      }
    } else {
      console.info("Waiting for ENTER key to stop tracing...");
      await endTracingPromise;
    }

    // Wait for Tracing.tracingComplete event
    let tracingComplete;
    try {
      tracingComplete = await new Promise((resolve) => {
        let resolved = false;
        client.once("Tracing.tracingComplete", (event) => {
          resolved = true;
          resolve(event);
        });
        setTimeout(() => {
          if (!resolved) {
            console.warn("Timeout waiting for Tracing.tracingComplete event");
            resolve(null);
          }
        }, 30000);
      });
    } catch (e) {
      console.error("Error waiting for tracingComplete:", e);
      tracingComplete = null;
    }

    const handle =
      tracingComplete && tracingComplete.stream ? tracingComplete.stream : null;
    let jsonBytes = 0,
      gzipBytes = 0;

    try {
      if (handle) {
        // Raccogli tutto il trace in memoria e scrivi il file completo
        const traceBuffer = await collectTraceData(client, handle);
        await fsp.writeFile(jsonPath, traceBuffer);
        jsonBytes = traceBuffer.length;
        try {
          const gzBuf = zlib.gzipSync(traceBuffer, {
            level: zlib.constants.Z_BEST_SPEED,
          });
          await fsp
            .writeFile(gzPath, gzBuf)
            .catch((e) => console.error("Failed writing gzip file", e));
          gzipBytes = gzBuf.length;
        } catch (e) {
          console.error("Failed creating gzip from buffer", e);
        }
      } else {
        const errorMsg = JSON.stringify(
          { error: "No trace stream handle, tracing failed or incomplete." },
          null,
          2
        );
        await fsp.writeFile(jsonPath, errorMsg);
        console.error("No trace stream handle, wrote fallback trace.json");
      }
    } catch (e) {
      // Fallback: always try to write something
      const errorMsg = JSON.stringify(
        { error: "Exception during trace collection", details: String(e) },
        null,
        2
      );
      await fsp.writeFile(jsonPath, errorMsg);
      console.error(
        "Exception during trace collection, wrote fallback trace.json"
      );
    }

    // Stop Profiler and write .cpuprofile
    try {
      const { profile } = await client.send("Profiler.stop");
      const cpuprofilePath = path.join(outDir, "trace.cpuprofile");
      await fsp.writeFile(cpuprofilePath, JSON.stringify(profile));
      console.info("Wrote CPU profile to", cpuprofilePath);
    } catch (e) {
      console.warn(
        "Profiler stop/save failed:",
        e && e.message ? e.message : e
      );
    }

    console.info("Wrote bytes:", { jsonBytes, gzipBytes });
    console.log("Wrote raw trace and gzip");

    // Move turbo files only if turbo enabled
    if (turbo) moveTurboFiles(turboDir);

    // Graceful shutdown of log streams
    closeStreams(() => {
      console.log("✅ Console log files closed.");
    });
  } finally {
    try {
      if (browser) await browser.close();
    } catch {}
    try {
      process.chdir(originalCwd);
    } catch {}
    // Exit only after all cleanup
    if (sigintReceived) process.exit(0);
  }
}

main().catch((e) => {
  console.error(e);
  process.exit(2);
});
