#!/usr/bin/env python3
import argparse
import os
import math
import logging
from typing import List, Optional, Dict, Any

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle

logging.basicConfig(level=logging.WARNING)

# Constants
DEFAULT_Y_MAX = 20000.0
FIGURE_WIDTH_PER_OPCODE = 0.7
FIGURE_HEIGHT = 6
CANDLE_WIDTH = 0.45
COLOR_ORIGINAL = "#00bcd4"
COLOR_OBFUSCATED = "orange"
LABEL_FONT_SIZE = 8
TICK_FONT_SIZE_Y = 9
TICK_FONT_SIZE_X = 10
MAX_Y_TICK_LABELS = 12
LABEL_SPACING_MULT = 1.8


def parse_int_cell(x: Any) -> float:
    if pd.isna(x) or x is None:
        return np.nan
    s = str(x).replace('"', "").replace("'", "").replace(",", "").strip()
    if not s:
        return np.nan
    try:
        return int(s)
    except ValueError:
        try:
            return int(float(s))
        except Exception:
            return np.nan


def load_csv(path: str) -> pd.DataFrame:
    return pd.read_csv(path, dtype=str, keep_default_na=False)


def compute_stats(series_values: List[float]) -> Dict[str, float]:
    arr = np.array(
        [v for v in series_values if not (v is None or np.isnan(v))], dtype=float
    )
    if arr.size == 0:
        return dict(min=np.nan, q1=np.nan, median=np.nan, q3=np.nan, max=np.nan)
    return dict(
        min=float(np.min(arr)),
        q1=float(np.percentile(arr, 25)),
        median=float(np.percentile(arr, 50)),
        q3=float(np.percentile(arr, 75)),
        max=float(np.max(arr)),
    )


def build_tick_sequence(max_y: int) -> List[int]:
    ticks = []
    ticks += list(range(0, 501, 50))
    ticks += list(range(500, 2001, 100))
    ticks += [2500, 3000, 3500, 4000, 4500, 5000]
    ticks += [10000, 15000, 20000]
    ticks = sorted(set(ticks))

    if max_y > 20000:
        top = int(math.ceil(max_y / 5000.0)) * 5000
        extra = list(range(25000, top + 1, 5000))
        ticks += extra
        ticks = sorted(set(ticks))

    ticks = [t for t in ticks if t <= max_y]
    if 0 not in ticks:
        ticks.insert(0, 0)
    if max_y not in ticks:
        ticks.append(max_y)

    return sorted(set(ticks))


def build_dynamic_ticks(max_y: float, max_labels: int = 16) -> list:
    """Generate ticks from 0 to max_y, spaced by 15% of max_y, max 16 ticks."""
    if max_y <= 0:
        return [0]
    step = max_y * 0.15
    ticks = [0]
    val = step
    while val < max_y and len(ticks) < max_labels - 1:
        ticks.append(round(val))
        val += step
    if ticks[-1] != round(max_y):
        ticks.append(round(max_y))
    return ticks


def subsample_ticks(ticks: List[int], max_labels: int = MAX_Y_TICK_LABELS) -> List[int]:
    if len(ticks) <= max_labels:
        return ticks
    keep = {ticks[0], ticks[-1]}
    high_threshold = 3500
    for t in ticks:
        if t >= high_threshold:
            keep.add(t)

    step = max(1, (len(ticks) - 2) // max(1, (max_labels - 2)))
    for i in range(1, len(ticks) - 1, step):
        keep.add(ticks[i])

    chosen = sorted([t for t in ticks if t in keep])

    if len(chosen) > max_labels:
        lower = [
            t for t in chosen if t < high_threshold and t not in (ticks[0], ticks[-1])
        ]
        while len(chosen) > max_labels and lower:
            chosen.remove(lower.pop(0))

    if len(chosen) > max_labels:
        nth = math.ceil(len(chosen) / max_labels)
        chosen = chosen[::nth]
        if chosen[-1] != ticks[-1]:
            chosen.append(ticks[-1])

    return chosen


def sanitize_name(s: Any) -> str:
    import re

    s = "" if s is None else str(s)
    s = s.strip()
    s = s.replace(" ", "_")
    s = re.sub(r"[^A-Za-z0-9._-]", "", s)
    if not s:
        s = "row"
    return s


def plot_opcode_comparison(
    opcodes: List[str],
    original_values: List[Optional[float]],
    obfuscated_stats_list: List[Dict[str, float]],
    outpath: str,
    y_max: float = DEFAULT_Y_MAX,
    comparison_label: Optional[str] = None,
) -> None:
    n = len(opcodes)
    fig_w = max(12, n * FIGURE_WIDTH_PER_OPCODE)
    fig, ax = plt.subplots(figsize=(fig_w, FIGURE_HEIGHT))

    xs = np.arange(n)
    width = CANDLE_WIDTH
    ymin, ymax = 0.0, float(y_max)

    label_box_height = max(1.0, (ymax - ymin) * 0.008)
    label_offset = label_box_height * LABEL_SPACING_MULT

    # Draw obfuscated candlesticks
    for i, stats in enumerate(obfuscated_stats_list):
        if np.isnan(stats["min"]):
            continue
        cx = xs[i] + width / 2
        ax.vlines(cx, stats["min"], stats["q1"], color=COLOR_OBFUSCATED, linewidth=1)
        ax.vlines(cx, stats["q3"], stats["max"], color=COLOR_OBFUSCATED, linewidth=1)

        yrange = max(1.0, ymax - ymin)
        min_box = max(1.0, yrange * 0.005)
        iqr = (
            stats["q3"] - stats["q1"]
            if not (np.isnan(stats["q3"]) or np.isnan(stats["q1"]))
            else 0.0
        )
        height = max(iqr, min_box)
        y0 = stats["q1"] if iqr > 0 else max(ymin, stats["q1"] - height / 2)
        box = Rectangle(
            (cx - width / 2, y0),
            width,
            height,
            facecolor=COLOR_OBFUSCATED,
            alpha=0.8,
            edgecolor="black",
        )
        ax.add_patch(box)

        if not np.isnan(stats["median"]):
            ax.hlines(
                stats["median"],
                cx - width / 2,
                cx + width / 2,
                color="black",
                linewidth=1,
            )

        try:
            mean_val = stats.get("mean")
            if mean_val is None or np.isnan(mean_val):
                vals = [stats.get(k) for k in ["min", "q1", "median", "q3", "max"]]
                vals = [float(v) for v in vals if v is not None and not np.isnan(v)]
                mean_val = float(np.mean(vals)) if vals else None
            if mean_val is not None:
                laby = min(ymax, mean_val + label_offset)
                ax.text(
                    cx,
                    laby,
                    f"{mean_val:,.0f}",
                    ha="center",
                    va="bottom",
                    fontsize=LABEL_FONT_SIZE,
                    color="black",
                )
        except Exception as e:
            logging.warning(
                f"Failed to draw mean label for obfuscated opcode index {i}: {e}"
            )

    # Draw original markers
    for i, value in enumerate(original_values):
        if value is None or np.isnan(value):
            continue
        cx = xs[i] - width / 2
        box_bottom = value - label_box_height / 2
        box = Rectangle(
            (cx - width / 2, box_bottom),
            width,
            label_box_height,
            facecolor=COLOR_ORIGINAL,
            alpha=0.95,
            edgecolor="black",
        )
        ax.add_patch(box)

        whisker_bottom = max(ymin, value - label_box_height * 1.5)
        whisker_top = min(ymax, value + label_box_height * 1.5)
        ax.vlines(cx, whisker_bottom, whisker_top, color="black", linewidth=1)

        try:
            laby = min(ymax, value + label_offset)
            ax.text(
                cx,
                laby,
                f"{value:,.0f}",
                ha="center",
                va="bottom",
                fontsize=LABEL_FONT_SIZE,
            )
        except Exception as e:
            logging.warning(f"Failed to draw label for original opcode index {i}: {e}")

    # Configure axes
    ax.set_xticks(xs)
    ax.set_xticklabels(opcodes, rotation=45, ha="right", fontsize=TICK_FONT_SIZE_X)
    ax.set_xlim(-1, n)

    # Imposta scala Y logaritmica
    ax.set_yscale("log")
    ax.set_ylim(max(ymin, 1), ymax)
    ax.set_ylabel("Number of occurrences (log scale)", fontsize=11)
    ax.set_xlabel("Opcode", fontsize=11)
    title = "Original (blue) vs Obfuscated variants (orange) per opcode"
    if comparison_label:
        title = f"{title} — compared to: {comparison_label}"
    ax.set_title(title, fontsize=12, fontweight="bold")
    ax.tick_params(axis="y", labelsize=TICK_FONT_SIZE_Y)

    # Imposta i tick logaritmici e mostra il massimo come ultimo tick a sinistra
    from matplotlib.ticker import LogLocator, LogFormatterSciNotation

    log_locator = LogLocator(base=10.0, numticks=10)
    log_formatter = LogFormatterSciNotation(base=10.0, labelOnlyBase=True)
    ax.yaxis.set_major_locator(log_locator)
    ax.yaxis.set_major_formatter(log_formatter)
    # Ensure ymax is a tick if not present
    yticks = ax.get_yticks()
    if ymax not in yticks:
        yticks = np.append(yticks, ymax)
        ax.set_yticks(yticks)

    # Add legend
    legend_elements = [
        Rectangle((0, 0), 1, 1, facecolor=COLOR_ORIGINAL, edgecolor="black"),
        Rectangle(
            (0, 0), 1, 1, facecolor=COLOR_OBFUSCATED, edgecolor="black", alpha=0.8
        ),
    ]
    ax.legend(
        legend_elements, ["Original", "Obfuscated"], loc="upper right", fontsize=10
    )

    plt.tight_layout()
    fig.savefig(outpath, dpi=150)
    plt.close(fig)
    print(f"✅ Chart created: {outpath}")  # <--- Added output for each chart


def main():
    parser = argparse.ArgumentParser(
        description="Create candlestick-style comparison chart from CSV"
    )
    parser.add_argument("csv", help="Input CSV file path")
    parser.add_argument("outdir", help="Output directory for PNG")
    parser.add_argument("--outfile", default="candlesticks.png", help="Output filename")
    parser.add_argument(
        "--max-opcodes", type=int, default=15, help="Max number of opcodes to plot"
    )
    parser.add_argument(
        "--y-max", type=float, default=DEFAULT_Y_MAX, help="Y-axis maximum"
    )
    parser.add_argument(
        "--inplace", action="store_true", help="Save in script directory"
    )
    parser.add_argument(
        "--skip-equal",
        action="store_true",
        help="Skip opcodes where original equals obfuscated",
    )
    parser.add_argument(
        "--all-opcodes",
        action="store_true",
        help="Consider all opcode columns when computing stats",
    )
    parser.add_argument(
        "--best", action="store_true", help="Sort opcodes by descending variation"
    )
    parser.add_argument(
        "--per-row",
        action="store_true",
        help="Create one chart per data row (excluding reference row)",
    )
    parser.add_argument(
        "--filename-col",
        default="filename",
        help="Column name to use for per-row output filenames (default: filename)",
    )

    args = parser.parse_args()

    df = load_csv(args.csv)
    cols = list(df.columns)
    if len(cols) < 3:
        raise SystemExit("CSV must have at least 3 columns.")

    opcode_cols = cols[2:]
    for col in opcode_cols:
        df[col] = df[col].apply(parse_int_cell)

    ref_row = df.iloc[0]
    original_all = [ref_row.get(col, np.nan) for col in opcode_cols]

    # compute obfuscated stats across rows (used for single-chart mode)
    dist_df = df.iloc[1:]
    obfuscated_stats_all = [compute_stats(dist_df[col].tolist()) for col in opcode_cols]

    # --- UNIFIED OPCODE SELECTION LOGIC ---
    opcode_work = list(opcode_cols)
    original_values = list(original_all)
    obfuscated_stats_list = list(obfuscated_stats_all)

    # Apply skip_equal filter
    if args.skip_equal:
        new_ops, new_orig, new_stats = [], [], []
        for op, orig, stats in zip(opcode_work, original_values, obfuscated_stats_list):
            try:
                if orig is None or np.isnan(orig):
                    keep = True
                else:
                    median = stats.get("median")
                    mn = stats.get("min")
                    mx = stats.get("max")
                    equal_median = (
                        median is not None and not np.isnan(median)
                    ) and float(median) == float(orig)
                    equal_all = (
                        mn is not None
                        and mx is not None
                        and not (np.isnan(mn) or np.isnan(mx))
                    ) and float(mn) == float(mx) == float(orig)
                    keep = not (equal_median or equal_all)
            except Exception:
                keep = True
            if keep:
                new_ops.append(op)
                new_orig.append(orig)
                new_stats.append(stats)
        opcode_work, original_values, obfuscated_stats_list = (
            new_ops,
            new_orig,
            new_stats,
        )

    # Apply best sorting
    if args.best:

        def variation_of(stats: Dict[str, float]) -> float:
            mn = stats.get("min")
            mx = stats.get("max")
            if mn is not None and mx is not None and not (np.isnan(mn) or np.isnan(mx)):
                return float(mx) - float(mn)
            return 0.0

        sorted_idx = sorted(
            range(len(obfuscated_stats_list)),
            key=lambda i: variation_of(obfuscated_stats_list[i]),
            reverse=True,
        )
        opcode_work = [opcode_work[i] for i in sorted_idx]
        original_values = [original_values[i] for i in sorted_idx]
        obfuscated_stats_list = [obfuscated_stats_list[i] for i in sorted_idx]

    if args.max_opcodes > 0:
        opcode_work = opcode_work[: args.max_opcodes]
        original_values = original_values[: args.max_opcodes]
        obfuscated_stats_list = obfuscated_stats_list[: args.max_opcodes]

    # determine output directory and y_max early so other branches can use them
    if args.inplace:
        outdir = os.path.dirname(os.path.abspath(__file__))
    else:
        outdir = args.outdir
        os.makedirs(outdir, exist_ok=True)

    y_max = float(args.y_max) if args.y_max is not None else DEFAULT_Y_MAX

    if args.per_row:
        # Use the same opcode selection as above
        selected_opcode_cols = opcode_work
        selected_original_values = original_values
        selected_idx = [opcode_cols.index(col) for col in selected_opcode_cols]

        # iterate each data row (skip first reference row)
        for idx in range(1, len(df)):
            row = df.iloc[idx]
            row_values = [parse_int_cell(row.get(col)) for col in opcode_cols]
            # compute trivial stats for a single row: min=q1=median=q3=max=value
            obf_stats = []
            for v in row_values:
                if v is None or (isinstance(v, float) and np.isnan(v)):
                    obf_stats.append(
                        dict(
                            min=np.nan, q1=np.nan, median=np.nan, q3=np.nan, max=np.nan
                        )
                    )
                else:
                    obf_stats.append(
                        dict(
                            min=float(v),
                            q1=float(v),
                            median=float(v),
                            q3=float(v),
                            max=float(v),
                        )
                    )

            # filter obf_stats to selected indices so every chart has same x-axis
            ow = list(selected_opcode_cols)
            ov = list(selected_original_values)
            osl = [obf_stats[i] for i in selected_idx]

            # determine filename from column
            fname = None
            if args.filename_col and args.filename_col in df.columns:
                raw = row.get(args.filename_col)
                fname = sanitize_name(raw) if raw is not None else None
            if not fname:
                fname = f"row_{idx}"

            outpath = os.path.join(outdir, f"{fname}.png")
            comp_label = None
            if args.filename_col and args.filename_col in df.columns:
                comp_label = row.get(args.filename_col)
            plot_opcode_comparison(
                ow, ov, osl, outpath, y_max=y_max, comparison_label=comp_label
            )
            print(f"✅ Wrote per-row chart: {outpath}")
        return  # <-- return only in per-row

    # Non-per-row: use the same opcode selection
    outpath = os.path.join(outdir, args.outfile)
    plot_opcode_comparison(
        opcode_work, original_values, obfuscated_stats_list, outpath, y_max=y_max
    )
    print(f"✅ Wrote chart to: {outpath}")


if __name__ == "__main__":
    main()
