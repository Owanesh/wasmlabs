#!/usr/bin/env python3
"""
Automated test runner for JavaScript libraries with Python server integration.
Tests multiple HTML files against a server and monitors for completion signals.
"""
import os
import sys
import time
import logging
import threading
import subprocess
import argparse
from pathlib import Path
from typing import List, Optional
from dataclasses import dataclass
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.common.exceptions import WebDriverException

# --- CONFIGURATION ---
@dataclass
class Config:
    html_folder: str = "composed/html"
    server_script: str = "../../cryptomock_server/server.py"
    chromedriver_path: str = "/opt/homebrew/bin/chromedriver"
    job_target: str = "Total hashes received by server: 101"
    timeout_server: int = 30
    timeout_selenium: int = 20
    log_level: str = "INFO"

# --- LOGGING ---
def setup_logging(level: str = "INFO") -> logging.Logger:
    logger = logging.getLogger(__name__)
    logger.setLevel(getattr(logging, level.upper()))
    
    if not logger.handlers:
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s', datefmt='%H:%M:%S')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
    
    return logger

# --- SERVER MANAGER ---
class ServerManager:
    def __init__(self, script_path: str, target: str, timeout: int, logger: logging.Logger):
        self.script_path = Path(script_path)
        self.target = target
        self.timeout = timeout
        self.logger = logger
        self.process: Optional[subprocess.Popen] = None
        self._target_found = threading.Event()
        self._stop_event = threading.Event()
        self._stdout_thread: Optional[threading.Thread] = None
        self._stderr_thread: Optional[threading.Thread] = None

    def start(self) -> bool:
        """Start server and return True if successful."""
        if not self.script_path.exists():
            self.logger.error(f"Server script not found: {self.script_path}")
            return False

        try:
            self._stop_event.clear()
            # start Python server
            self.process = subprocess.Popen(
                [sys.executable, str(self.script_path)],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                bufsize=1
            )

            # start reader threads
            self._stdout_thread = threading.Thread(target=self._read_stream, args=(self.process.stdout, False), daemon=True)
            self._stderr_thread = threading.Thread(target=self._read_stream, args=(self.process.stderr, True), daemon=True)
            self._stdout_thread.start()
            self._stderr_thread.start()

            # give server a short time to initialize
            time.sleep(1.5)

            if self.process.poll() is not None:
                # process already exited, capture output
                try:
                    stdout, stderr = self.process.communicate(timeout=1)
                except Exception:
                    stdout, stderr = ("", "")
                self.logger.error(f"Server failed to start. Exit code: {self.process.returncode}")
                self.logger.error(f"Stdout: {stdout}")
                self.logger.error(f"Stderr: {stderr}")
                return False

            self.logger.info(f"Server started with PID: {self.process.pid}")
            return True

        except Exception as e:
            self.logger.error(f"Failed to start server: {e}")
            return False

    def _read_stream(self, stream, is_stderr=False):
        """Read and log lines from a stream. Set target event when matched."""
        try:
            # iterate lines until stream closes or stop event is set
            while not self._stop_event.is_set():
                line = stream.readline()
                if line == "":
                    # EOF reached
                    break
                line = line.rstrip()
                if line:
                    prefix = "SERVER STDERR:" if is_stderr else "SERVER:"
                    self.logger.info(f"{prefix} {line}")
                    # match target in either stdout or stderr
                    if self.target in line:
                        self.logger.info(f"✓ Target found in server output: {self.target}")
                        self._target_found.set()
                        # don't call stop() from this thread (avoid join deadlocks)
                        break
        except Exception as e:
            self.logger.error(f"Error reading server output: {e}")

    def wait_for_target(self) -> bool:
        """Wait for target string in server output. Return True if found within timeout."""
        if not self.process:
            return False
        found = self._target_found.wait(timeout=self.timeout)
        if not found:
            self.logger.warning(f"Target not found within {self.timeout}s")
        else:
            self.logger.info("Target event set.")
        return found

    def stop(self):
        """Stop the server and ensure reader threads exit."""
        # signal readers to stop
        self._stop_event.set()

        if self.process:
            try:
                # try graceful terminate
                self.process.terminate()
                try:
                    self.process.wait(timeout=3)
                except subprocess.TimeoutExpired:
                    self.logger.debug("Server did not terminate quickly; killing")
                    self.process.kill()
                    self.process.wait(timeout=2)
            except Exception as e:
                self.logger.error(f"Error stopping server process: {e}")
            finally:
                # close streams to unblock reader threads
                try:
                    if self.process.stdout:
                        try:
                            self.process.stdout.close()
                        except Exception:
                            pass
                    if self.process.stderr:
                        try:
                            self.process.stderr.close()
                        except Exception:
                            pass
                except Exception:
                    pass

                self.logger.info("Server stopped")
                self.process = None
                self._target_found.clear()

        # join threads
        if self._stdout_thread and self._stdout_thread.is_alive():
            self._stdout_thread.join(timeout=1)
        if self._stderr_thread and self._stderr_thread.is_alive():
            self._stderr_thread.join(timeout=1)

# --- SELENIUM MANAGER ---
class SeleniumManager:
    def __init__(self, chromedriver_path: str, timeout: int, logger: logging.Logger):
        self.chromedriver_path = Path(chromedriver_path)
        self.timeout = timeout
        self.logger = logger
        self.driver: Optional[webdriver.Chrome] = None
    
    def start(self) -> bool:
        """Start Chrome WebDriver."""
        if not self.chromedriver_path.exists():
            self.logger.error(f"Chromedriver not found: {self.chromedriver_path}")
            return False
        
        options = Options()
        # headless modern flag if available; fallback will be ignored on older versions
        options.add_argument("--headless=new")
        options.add_argument("--disable-gpu")
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")
        options.add_argument("--ignore-certificate-errors")
        options.add_argument("--allow-insecure-localhost")
        # enable browser logs
        options.set_capability("goog:loggingPrefs", {"browser": "ALL"})
        
        try:
            service = Service(str(self.chromedriver_path))
            self.driver = webdriver.Chrome(service=service, options=options)
            self.driver.set_page_load_timeout(self.timeout)
            self.logger.info("Selenium WebDriver started")
            return True
        except Exception as e:
            self.logger.error(f"Failed to start WebDriver: {e}")
            return False
    
    def load_page(self, html_path: str) -> List[dict]:
        """Load HTML page and return console logs."""
        if not self.driver:
            return []
        
        try:
            file_url = f"file://{Path(html_path).resolve()}"
            self.logger.info(f"Loading page: {file_url}")
            self.driver.get(file_url)
            # give page some time to execute scripts and open sockets
            time.sleep(min(5, max(2, int(self.timeout / 2))))
            
            try:
                return self.driver.get_log("browser")
            except WebDriverException:
                return []
        except Exception as e:
            self.logger.error(f"Failed to load page: {e}")
            return []
    
    def stop(self):
        """Stop WebDriver."""
        if self.driver:
            try:
                self.driver.quit()
                self.logger.info("Selenium WebDriver stopped")
            except Exception as e:
                self.logger.error(f"Error stopping WebDriver: {e}")
            finally:
                self.driver = None

# --- MAIN TEST RUNNER ---
class TestRunner:
    def __init__(self, config: Config):
        self.config = config
        self.logger = setup_logging(config.log_level)
        self.results = []

    def get_html_files(self) -> List[str]:
        """Get HTML files to test."""
        html_folder = Path(self.config.html_folder)
        if not html_folder.exists():
            raise Exception(f"HTML folder not found: {html_folder}")

        html_files = sorted([str(f.resolve()) for f in html_folder.glob("*.html")])
        if not html_files:
            raise Exception(f"No HTML files found in {html_folder}")

        self.logger.info(f"Found {len(html_files)} HTML files")
        return html_files

    def categorize_js_error(self, message: str) -> str:
        """Simple error categorization."""
        message_lower = message.lower()
        
        if 'connection' in message_lower and ('websocket' in message_lower or 'refused' in message_lower):
            return 'connection'
        elif 'webassembly' in message_lower or 'wasm' in message_lower:
            return 'webassembly'
        elif any(word in message_lower for word in ['typeerror', 'referenceerror', 'syntaxerror']):
            return 'critical'
        else:
            return 'other'

    def test_html_file(self, html_path: str) -> dict:
        """Test a single HTML file."""
        filename = os.path.basename(html_path)
        result = {
            'filename': filename,
            'success': False,
            'error': None,
            'skipped': False,
            'skip_reason': None,
            'js_errors': []
        }

        self.logger.info(f"\n{'='*50}")
        self.logger.info(f"Testing: {filename}")
        self.logger.info(f"{'='*50}")

        server: Optional[ServerManager] = None
        selenium: Optional[SeleniumManager] = None

        try:
            # 1. Avvia server sempre
            server = ServerManager(self.config.server_script, self.config.job_target, 
                                   self.config.timeout_server, self.logger)
            if not server.start():
                result['error'] = "Failed to start server"
                return result

            # 2. Avvia Selenium sempre
            selenium = SeleniumManager(self.config.chromedriver_path, self.config.timeout_selenium, self.logger)
            if not selenium.start():
                result['error'] = "Failed to start Selenium"
                return result

            # 3. Carica pagina (server è attivo → no connection refused)
            logs = selenium.load_page(html_path)

            # 4. Controlla errori JS
            critical_errors = 0
            webasm_errors = 0
            connection_errors = 0

            for log_entry in logs:
                level = log_entry.get('level')
                if level and level.upper() in ('SEVERE', 'ERROR'):
                    message = log_entry.get('message', '')
                    result['js_errors'].append(message)
                    error_type = self.categorize_js_error(message)
                    if error_type == 'critical':
                        critical_errors += 1
                        self.logger.error(f"CRITICAL JS: {message}")
                    elif error_type == 'webassembly':
                        webasm_errors += 1
                        self.logger.error(f"WEBASM: {message}")
                    elif error_type == 'connection':
                        connection_errors += 1
                        self.logger.warning(f"CONNECTION: {message}")
                    else:
                        self.logger.warning(f"JS ERROR: {message}")

            # 5. Se errori critici → marca come skipped, ferma server e selenium e passa oltre
            if critical_errors > 0:
                result['skipped'] = True
                result['skip_reason'] = f"Critical JS errors: {critical_errors}"
                self.logger.warning(f"⏭️  SKIPPING: {result['skip_reason']}")
                return result
            if webasm_errors > 0:
                result['skipped'] = True
                result['skip_reason'] = f"WebAssembly errors: {webasm_errors}"
                self.logger.warning(f"⏭️  SKIPPING: {result['skip_reason']}")
                return result

            # 6. Se no errori critici → aspetta target dal server
            self.logger.info("No critical errors found, waiting for server target...")
            found = server.wait_for_target()

            if found:
                result['success'] = True
                self.logger.info("🎉 TEST PASSED (target reached)")
            else:
                result['success'] = False
                result['error'] = "Target not reached within timeout"
                self.logger.warning("❌ TEST FAILED: Target not reached")

            return result

        except Exception as e:
            result['error'] = str(e)
            self.logger.error(f"Test failed: {e}")
            return result

        finally:
            # 7. Cleanup sempre eseguito (finally block)
            try:
                if selenium:
                    selenium.stop()
            except Exception:
                pass
            try:
                if server:
                    # ensure server stopped before next test
                    server.stop()
                # small pause to ensure OS releases resources
                time.sleep(0.5)
            except Exception:
                pass

    def run_all_tests(self):
        """Run tests for all HTML files."""
        try:
            html_files = self.get_html_files()
            
            for i, html_file in enumerate(html_files, 1):
                self.logger.info(f"[{i}/{len(html_files)}] {os.path.basename(html_file)}")
                
                result = self.test_html_file(html_file)
                self.results.append(result)

            self.print_summary()

        except Exception as e:
            self.logger.error(f"Test run failed: {e}")
            raise

    def print_summary(self):
        """Print test summary."""
        total = len(self.results)
        passed = sum(1 for r in self.results if r['success'])
        failed = sum(1 for r in self.results if not r['success'] and not r['skipped'])
        skipped = sum(1 for r in self.results if r['skipped'])
        
        self.logger.info(f"\n{'='*60}")
        self.logger.info("SUMMARY")
        self.logger.info(f"Total: {total} | Passed: {passed} | Failed: {failed} | Skipped: {skipped}")
        
        if failed > 0:
            self.logger.info("\nFAILED:")
            for r in self.results:
                if not r['success'] and not r['skipped']:
                    reason = r['error'] or f"Target not reached ({len(r['js_errors'])} JS errors)"
                    self.logger.error(f"  {r['filename']}: {reason}")

        if skipped > 0:
            self.logger.info("\nSKIPPED:")
            for r in self.results:
                if r['skipped']:
                    self.logger.warning(f"  {r['filename']}: {r['skip_reason']}")

def main():
    parser = argparse.ArgumentParser(description="Test runner for JavaScript libraries")
    parser.add_argument("--html-folder", default="composed/html", help="HTML files folder")
    parser.add_argument("--server-script", default="../../cryptomock_server/server.py", help="Server script path")
    parser.add_argument("--chromedriver", default="/opt/homebrew/bin/chromedriver", help="Chromedriver path")
    parser.add_argument("--job-target", default="Total hashes received by server: 3", help="Target string")
    parser.add_argument("--timeout-server", type=int, default=30, help="Server timeout")
    parser.add_argument("--timeout-selenium", type=int, default=20, help="Selenium timeout")
    parser.add_argument("--log-level", default='INFO', choices=['DEBUG', 'INFO', 'WARNING', 'ERROR'])

    args = parser.parse_args()
    
    config = Config(
        html_folder=args.html_folder,
        server_script=args.server_script,
        chromedriver_path=args.chromedriver,
        job_target=args.job_target,
        timeout_server=args.timeout_server,
        timeout_selenium=args.timeout_selenium,
        log_level=args.log_level
    )
    
    runner = TestRunner(config)
    try:
        runner.run_all_tests()
        
        failed_count = sum(1 for r in runner.results if not r['success'] and not r['skipped'])
        sys.exit(1 if failed_count > 0 else 0)
        
    except KeyboardInterrupt:
        print("\nTest run interrupted")
        sys.exit(1)
    except Exception as e:
        print(f"Test run failed: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()