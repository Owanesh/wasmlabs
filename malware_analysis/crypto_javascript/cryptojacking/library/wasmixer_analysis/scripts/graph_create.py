#!/usr/bin/env python3
import argparse
import os
import math
import logging
from typing import List, Optional, Dict, Any

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle

logging.basicConfig(level=logging.WARNING)

# Constants
DEFAULT_Y_MAX = 20000.0
FIGURE_WIDTH_PER_OPCODE = 0.7
FIGURE_HEIGHT = 6
CANDLE_WIDTH = 0.45
COLOR_ORIGINAL = "#00bcd4"
COLOR_OBFUSCATED = "orange"
LABEL_FONT_SIZE = 8
TICK_FONT_SIZE_Y = 9
TICK_FONT_SIZE_X = 10
MAX_Y_TICK_LABELS = 12
LABEL_SPACING_MULT = 1.8


def parse_int_cell(x: Any) -> float:
    if pd.isna(x) or x is None:
        return np.nan
    s = str(x).replace('"', "").replace("'", "").replace(",", "").strip()
    if not s:
        return np.nan
    try:
        return int(s)
    except ValueError:
        try:
            return int(float(s))
        except Exception:
            return np.nan


def load_csv(path: str) -> pd.DataFrame:
    return pd.read_csv(path, dtype=str, keep_default_na=False)


def compute_stats(series_values: List[float]) -> Dict[str, float]:
    arr = np.array(
        [v for v in series_values if not (v is None or np.isnan(v))], dtype=float
    )
    if arr.size == 0:
        return dict(min=np.nan, q1=np.nan, median=np.nan, q3=np.nan, max=np.nan)
    return dict(
        min=float(np.min(arr)),
        q1=float(np.percentile(arr, 25)),
        median=float(np.percentile(arr, 50)),
        q3=float(np.percentile(arr, 75)),
        max=float(np.max(arr)),
    )


def build_tick_sequence(max_y: int) -> List[int]:
    ticks = []
    ticks += list(range(0, 501, 50))
    ticks += list(range(500, 2001, 100))
    ticks += [2500, 3000, 3500, 4000, 4500, 5000]
    ticks += [10000, 15000, 20000]
    ticks = sorted(set(ticks))

    if max_y > 20000:
        top = int(math.ceil(max_y / 5000.0)) * 5000
        extra = list(range(25000, top + 1, 5000))
        ticks += extra
        ticks = sorted(set(ticks))

    ticks = [t for t in ticks if t <= max_y]
    if 0 not in ticks:
        ticks.insert(0, 0)
    if max_y not in ticks:
        ticks.append(max_y)

    return sorted(set(ticks))


def subsample_ticks(ticks: List[int], max_labels: int = MAX_Y_TICK_LABELS) -> List[int]:
    if len(ticks) <= max_labels:
        return ticks
    keep = {ticks[0], ticks[-1]}
    high_threshold = 3500
    for t in ticks:
        if t >= high_threshold:
            keep.add(t)

    step = max(1, (len(ticks) - 2) // max(1, (max_labels - 2)))
    for i in range(1, len(ticks) - 1, step):
        keep.add(ticks[i])

    chosen = sorted([t for t in ticks if t in keep])

    if len(chosen) > max_labels:
        lower = [
            t for t in chosen if t < high_threshold and t not in (ticks[0], ticks[-1])
        ]
        while len(chosen) > max_labels and lower:
            chosen.remove(lower.pop(0))

    if len(chosen) > max_labels:
        nth = math.ceil(len(chosen) / max_labels)
        chosen = chosen[::nth]
        if chosen[-1] != ticks[-1]:
            chosen.append(ticks[-1])

    return chosen


def sanitize_name(s: Any) -> str:
    import re

    s = "" if s is None else str(s)
    s = s.strip()
    s = s.replace(" ", "_")
    s = re.sub(r"[^A-Za-z0-9._-]", "", s)
    if not s:
        s = "row"
    return s


def plot_opcode_comparison(
    opcodes: List[str],
    original_values: List[Optional[float]],
    obfuscated_stats_list: List[Dict[str, float]],
    outpath: str,
    y_max: float = DEFAULT_Y_MAX,
    comparison_label: Optional[str] = None,
) -> None:
    n = len(opcodes)
    fig_w = max(12, n * FIGURE_WIDTH_PER_OPCODE)
    fig, ax = plt.subplots(figsize=(fig_w, FIGURE_HEIGHT))

    xs = np.arange(n)
    width = CANDLE_WIDTH
    ymin, ymax = 0.0, float(y_max)

    label_box_height = max(1.0, (ymax - ymin) * 0.008)
    label_offset = label_box_height * LABEL_SPACING_MULT

    # Draw obfuscated candlesticks
    for i, stats in enumerate(obfuscated_stats_list):
        if np.isnan(stats["min"]):
            continue
        cx = xs[i] + width / 2
        ax.vlines(cx, stats["min"], stats["q1"], color=COLOR_OBFUSCATED, linewidth=1)
        ax.vlines(cx, stats["q3"], stats["max"], color=COLOR_OBFUSCATED, linewidth=1)

        yrange = max(1.0, ymax - ymin)
        min_box = max(1.0, yrange * 0.005)
        iqr = (
            stats["q3"] - stats["q1"]
            if not (np.isnan(stats["q3"]) or np.isnan(stats["q1"]))
            else 0.0
        )
        height = max(iqr, min_box)
        y0 = stats["q1"] if iqr > 0 else max(ymin, stats["q1"] - height / 2)
        box = Rectangle(
            (cx - width / 2, y0),
            width,
            height,
            facecolor=COLOR_OBFUSCATED,
            alpha=0.8,
            edgecolor="black",
        )
        ax.add_patch(box)

        if not np.isnan(stats["median"]):
            ax.hlines(
                stats["median"],
                cx - width / 2,
                cx + width / 2,
                color="black",
                linewidth=1,
            )

        try:
            mean_val = stats.get("mean")
            if mean_val is None or np.isnan(mean_val):
                vals = [stats.get(k) for k in ["min", "q1", "median", "q3", "max"]]
                vals = [float(v) for v in vals if v is not None and not np.isnan(v)]
                mean_val = float(np.mean(vals)) if vals else None
            if mean_val is not None:
                laby = min(ymax, mean_val + label_offset)
                ax.text(
                    cx,
                    laby,
                    f"{mean_val:,.0f}",
                    ha="center",
                    va="bottom",
                    fontsize=LABEL_FONT_SIZE,
                    color="black",
                )
        except Exception as e:
            logging.warning(
                f"Failed to draw mean label for obfuscated opcode index {i}: {e}"
            )

    # Draw original markers
    for i, value in enumerate(original_values):
        if value is None or np.isnan(value):
            continue
        cx = xs[i] - width / 2
        box_bottom = value - label_box_height / 2
        box = Rectangle(
            (cx - width / 2, box_bottom),
            width,
            label_box_height,
            facecolor=COLOR_ORIGINAL,
            alpha=0.95,
            edgecolor="black",
        )
        ax.add_patch(box)

        whisker_bottom = max(ymin, value - label_box_height * 1.5)
        whisker_top = min(ymax, value + label_box_height * 1.5)
        ax.vlines(cx, whisker_bottom, whisker_top, color="black", linewidth=1)

        try:
            laby = min(ymax, value + label_offset)
            ax.text(
                cx,
                laby,
                f"{value:,.0f}",
                ha="center",
                va="bottom",
                fontsize=LABEL_FONT_SIZE,
            )
        except Exception as e:
            logging.warning(f"Failed to draw label for original opcode index {i}: {e}")

    # Configure axes
    ax.set_xticks(xs)
    ax.set_xticklabels(opcodes, rotation=45, ha="right", fontsize=TICK_FONT_SIZE_X)
    ax.set_xlim(-1, n)

    ticks = build_tick_sequence(int(ymax))
    ticks = subsample_ticks(ticks, max_labels=MAX_Y_TICK_LABELS)
    ax.set_yticks(ticks)
    ax.set_ylim(ymin, ymax)
    ax.set_ylabel("Number of occurrences", fontsize=11)
    ax.set_xlabel("Opcode", fontsize=11)
    title = "Original (blue) vs Obfuscated variants (orange) per opcode"
    if comparison_label:
        title = f"{title} — compared to: {comparison_label}"
    ax.set_title(title, fontsize=12, fontweight="bold")
    ax.tick_params(axis="y", labelsize=TICK_FONT_SIZE_Y)

    # Add legend
    legend_elements = [
        Rectangle((0, 0), 1, 1, facecolor=COLOR_ORIGINAL, edgecolor="black"),
        Rectangle(
            (0, 0), 1, 1, facecolor=COLOR_OBFUSCATED, edgecolor="black", alpha=0.8
        ),
    ]
    ax.legend(
        legend_elements, ["Original", "Obfuscated"], loc="upper right", fontsize=10
    )

    plt.tight_layout()
    fig.savefig(outpath, dpi=150)
    plt.close(fig)
    print(f"✅ Chart created: {outpath}")  # <--- Added output for each chart


def main():
    parser = argparse.ArgumentParser(
        description="Create candlestick-style comparison chart from CSV"
    )
    parser.add_argument("csv", help="Input CSV file path")
    parser.add_argument("outdir", help="Output directory for PNG")
    parser.add_argument("--outfile", default="candlesticks.png", help="Output filename")
    parser.add_argument(
        "--max-opcodes", type=int, default=15, help="Max number of opcodes to plot"
    )
    parser.add_argument(
        "--y-max", type=float, default=DEFAULT_Y_MAX, help="Y-axis maximum"
    )
    parser.add_argument(
        "--inplace", action="store_true", help="Save in script directory"
    )
    parser.add_argument(
        "--skip-equal",
        action="store_true",
        help="Skip opcodes where original equals obfuscated",
    )
    parser.add_argument(
        "--all-opcodes",
        action="store_true",
        help="Consider all opcode columns when computing stats",
    )
    parser.add_argument(
        "--best", action="store_true", help="Sort opcodes by descending variation"
    )
    parser.add_argument(
        "--per-row",
        action="store_true",
        help="Create one chart per data row (excluding reference row)",
    )
    parser.add_argument(
        "--filename-col",
        default="filename",
        help="Column name to use for per-row output filenames (default: filename)",
    )

    args = parser.parse_args()

    df = load_csv(args.csv)
    cols = list(df.columns)
    if len(cols) < 3:
        raise SystemExit("CSV must have at least 3 columns.")

    opcode_cols = cols[2:]
    for col in opcode_cols:
        df[col] = df[col].apply(parse_int_cell)

    ref_row = df.iloc[0]
    original_all = [ref_row.get(col, np.nan) for col in opcode_cols]

    # compute obfuscated stats across rows (used for single-chart mode)
    dist_df = df.iloc[1:]
    obfuscated_stats_all = [compute_stats(dist_df[col].tolist()) for col in opcode_cols]

    opcode_work = list(opcode_cols)
    original_values = list(original_all)
    obfuscated_stats_list = list(obfuscated_stats_all)
    # determine output directory and y_max early so other branches can use them
    if args.inplace:
        outdir = os.path.dirname(os.path.abspath(__file__))
    else:
        outdir = args.outdir
        os.makedirs(outdir, exist_ok=True)

    y_max = float(args.y_max) if args.y_max is not None else DEFAULT_Y_MAX
    if args.per_row:
        # build a fixed opcode selection (same x-axis for all per-row charts)
        selected_idx = list(range(len(opcode_cols)))
        # if skip_equal: remove opcodes that have no variation across obfuscated rows
        if args.skip_equal:
            new_idx = []
            for i, stats in enumerate(obfuscated_stats_all):
                try:
                    mn = stats.get("min")
                    mx = stats.get("max")
                    if mn is None or mx is None or np.isnan(mn) or np.isnan(mx):
                        # keep if stats missing
                        new_idx.append(i)
                    else:
                        if float(mn) == float(mx):
                            # skip opcode with no variation across obfuscated rows
                            continue
                        else:
                            new_idx.append(i)
                except Exception:
                    new_idx.append(i)
            selected_idx = new_idx

        # apply 'best' sorting to selected indices if requested
        if args.best:

            def variation_of_idx(i: int) -> float:
                stats = obfuscated_stats_all[i]
                try:
                    mn = stats.get("min")
                    mx = stats.get("max")
                    if (
                        mn is not None
                        and mx is not None
                        and not (np.isnan(mn) or np.isnan(mx))
                    ):
                        return float(mx) - float(mn)
                    q1 = stats.get("q1")
                    q3 = stats.get("q3")
                    if (
                        q1 is not None
                        and q3 is not None
                        and not (np.isnan(q1) or np.isnan(q3))
                    ):
                        return float(q3) - float(q1)
                except Exception:
                    pass
                return 0.0

            selected_idx = sorted(
                selected_idx, key=lambda i: variation_of_idx(i), reverse=True
            )

        # apply max_opcodes limit
        if args.max_opcodes > 0:
            selected_idx = selected_idx[: args.max_opcodes]

        # build selected opcode lists used for every row
        selected_opcode_cols = [opcode_cols[i] for i in selected_idx]
        selected_original_values = [original_all[i] for i in selected_idx]

        # iterate each data row (skip first reference row)
        for idx in range(1, len(df)):
            row = df.iloc[idx]
            row_values = [parse_int_cell(row.get(col)) for col in opcode_cols]
            # compute trivial stats for a single row: min=q1=median=q3=max=value
            obf_stats = []
            for v in row_values:
                if v is None or (isinstance(v, float) and np.isnan(v)):
                    obf_stats.append(
                        dict(
                            min=np.nan, q1=np.nan, median=np.nan, q3=np.nan, max=np.nan
                        )
                    )
                else:
                    obf_stats.append(
                        dict(
                            min=float(v),
                            q1=float(v),
                            median=float(v),
                            q3=float(v),
                            max=float(v),
                        )
                    )

            # filter obf_stats to selected indices so every chart has same x-axis
            ow = list(selected_opcode_cols)
            ov = list(selected_original_values)
            osl = [obf_stats[i] for i in selected_idx]

            # determine filename from column
            fname = None
            if args.filename_col and args.filename_col in df.columns:
                raw = row.get(args.filename_col)
                fname = sanitize_name(raw) if raw is not None else None
            if not fname:
                fname = f"row_{idx}"

            outpath = os.path.join(outdir, f"{fname}.png")
            comp_label = None
            if args.filename_col and args.filename_col in df.columns:
                comp_label = row.get(args.filename_col)
            plot_opcode_comparison(
                ow, ov, osl, outpath, y_max=y_max, comparison_label=comp_label
            )
            print(f"✅ Wrote per-row chart: {outpath}")
        return  # <-- Il return ora è SOLO dentro il blocco per-row

    # Il resto del codice ora viene eseguito se non c'è --per-row
    if args.skip_equal:
        new_ops, new_orig, new_stats = [], [], []
        for op, orig, stats in zip(opcode_work, original_values, obfuscated_stats_list):
            try:
                if orig is None or np.isnan(orig):
                    keep = True
                else:
                    median = stats.get("median")
                    mn = stats.get("min")
                    mx = stats.get("max")
                    equal_median = (
                        median is not None and not np.isnan(median)
                    ) and float(median) == float(orig)
                    equal_all = (
                        mn is not None
                        and mx is not None
                        and not (np.isnan(mn) or np.isnan(mx))
                    ) and float(mn) == float(mx) == float(orig)
                    keep = not (equal_median or equal_all)
            except Exception:
                keep = True
            if keep:
                new_ops.append(op)
                new_orig.append(orig)
                new_stats.append(stats)
        opcode_work, original_values, obfuscated_stats_list = (
            new_ops,
            new_orig,
            new_stats,
        )

    if args.best:

        def variation_of(stats: Dict[str, float]) -> float:
            try:
                mn = stats.get("min")
                mx = stats.get("max")
                if (
                    mn is not None
                    and mx is not None
                    and not (np.isnan(mn) or np.isnan(mx))
                ):
                    return float(mx) - float(mn)
                q1 = stats.get("q1")
                q3 = stats.get("q3")
                if (
                    q1 is not None
                    and q3 is not None
                    and not (np.isnan(q1) or np.isnan(q3))
                ):
                    return float(q3) - float(q1)
            except Exception:
                pass
            return 0.0

        sorted_idx = sorted(
            range(len(obfuscated_stats_list)),
            key=lambda i: variation_of(obfuscated_stats_list[i]),
            reverse=True,
        )
        opcode_work = [opcode_work[i] for i in sorted_idx]
        original_values = [original_values[i] for i in sorted_idx]
        obfuscated_stats_list = [obfuscated_stats_list[i] for i in sorted_idx]

    if args.max_opcodes > 0:
        opcode_work = opcode_work[: args.max_opcodes]
        original_values = original_values[: args.max_opcodes]
        obfuscated_stats_list = obfuscated_stats_list[: args.max_opcodes]

    outpath = os.path.join(outdir, args.outfile)

    plot_opcode_comparison(
        opcode_work, original_values, obfuscated_stats_list, outpath, y_max=y_max
    )
    print(f"✅ Wrote chart to: {outpath}")


if __name__ == "__main__":
    main()
