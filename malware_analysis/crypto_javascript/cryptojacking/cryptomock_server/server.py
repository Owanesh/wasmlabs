import asyncio
import json
import logging
from aiohttp import web, WSMsgType
from aiohttp.web_ws import WebSocketResponse
from typing import Any, Dict
from datetime import datetime
import os

# SSL utilities
from https.utils import load_ssl_context
from logger import setup_logger
 
# Configuration
SERVER_HOST = "127.0.0.1"
SERVER_PORT = 8000
USE_SSL = True

# Global mining state
mining_state = {
    "connections": [],
    "hashes_submitted": 0,
    "current_job_id": 1
}

setup_logger()
# HTTP Routes
async def handle_index(request):
    """Main page with SSL and WebSocket test."""
    html = f"""
    <!DOCTYPE html>
    <html>
    <head><title>CryptoMock Server</title></head>
    <body>
        <h1>CryptoMock Server Running</h1>
        <p>Server running on port {SERVER_PORT}</p>
        <div id="status">Testing WebSocket...</div>
        <script>
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const ws = new WebSocket(`${{protocol}}//{SERVER_HOST}:{SERVER_PORT}/ws`);
            
            ws.onopen = () => {{
                document.getElementById('status').innerHTML = '<p style="color:green">‚úÖ WebSocket connected successfully!</p>';
                console.log('WebSocket connected!');
            }};
            
            ws.onerror = (error) => {{
                document.getElementById('status').innerHTML = '<p style="color:red">‚ùå WebSocket connection failed</p>';
                console.error('WebSocket error:', error);
            }};
            
            ws.onmessage = (event) => {{
                console.log('Received:', JSON.parse(event.data));
            }};
        </script>
    </body>
    </html>
    """
    return web.Response(text=html, content_type='text/html')

async def handle_worker(request):
    """Mock worker script."""
    worker_js = """
    // Mock CryptoMock worker
    self.onmessage = function(e) {
        var job = e.data;
        var hashesPerSecond = 100 + Math.random() * 50;
        
        // Simulate finding a result occasionally
        if (Math.random() < 0.001) {
            self.postMessage({
                result: "mock_result_" + Math.random().toString(36).substr(2, 9),
                job_id: job.job_id || 'mock_job',
                nonce: Math.floor(Math.random() * 1000000),
                hashes: 0,
                hashesPerSecond: hashesPerSecond
            });
        } else {
            self.postMessage({
                hashes: 0,
                hashesPerSecond: hashesPerSecond
            });
        }
    };
    
    // Signal that worker is ready
    self.postMessage("ready");
    """
    return web.Response(text=worker_js, content_type='application/javascript')

async def handle_websocket(request):
    """Handle WebSocket connections."""
    ws = WebSocketResponse(heartbeat=30)
    await ws.prepare(request)
    
    client_id = f"{request.remote}:{id(ws)}"
    logging.info(f"WebSocket connected: {client_id}")
    
    # Add to connections
    connection = {
        "id": client_id,
        "websocket": ws,
        "authenticated": False
    }
    mining_state["connections"].append(connection)
    
    try:
        # Send welcome message
        welcome = {
            "type": "server_info",
            "params": {
                "message": "Connected to CryptoMock",
                "server_time": datetime.now().isoformat()
            }
        }
        logging.info(f"[WELCOME] Server -> Client {client_id}")
        logging.info(f"[WELCOME] Sending welcome message: {json.dumps(welcome, indent=2)}")
        await ws.send_str(json.dumps(welcome))
        
        # Message loop
        async for msg in ws:
            if msg.type == WSMsgType.TEXT:
                try:
                    data = json.loads(msg.data)
                    logging.info(f"[RECEIVED] Client {client_id} -> Server")
                    logging.info(f"[RECEIVED] Raw JSON: {json.dumps(data, indent=2)}")
                    logging.info(f"[RECEIVED] Message type: {data.get('type', 'UNKNOWN')}")
                    # if 'params' in data:
                    #     logging.info(f"[RECEIVED] Params: {json.dumps(data['params'], indent=2)}")
                    
                    response = await process_message(data, client_id)
                    if response:
                        logging.info(f"[SENDING] Server -> Client {client_id}")
                        # logging.info(f"[SENDING] Response JSON: {json.dumps(response, indent=2)}")
                        await ws.send_str(json.dumps(response))
                        
                except json.JSONDecodeError as e:
                    logging.error(f"[ERROR] Invalid JSON from {client_id}: {msg.data}")
                    logging.error(f"[ERROR] JSON decode error: {e}")
                except Exception as e:
                    logging.error(f"[ERROR] Message processing error for {client_id}: {e}")
                    import traceback
                    logging.error(f"[ERROR] Traceback: {traceback.format_exc()}")
                    
            elif msg.type == WSMsgType.ERROR:
                logging.error(f"[ERROR] WebSocket error for {client_id}: {ws.exception()}")
                break
                
    except Exception as e:
        logging.error(f"WebSocket handler error for {client_id}: {e}")
    finally:
        # Cleanup
        mining_state["connections"] = [c for c in mining_state["connections"] if c["id"] != client_id]
        logging.info(f"WebSocket disconnected: {client_id}")
    
    return ws

async def process_message(data: Dict[str, Any], client_id: str):
    """Process incoming WebSocket messages."""
    msg_type = data.get("type")
    params = data.get("params", {})
    
    logging.info(f"[PROCESSING] Message type: {msg_type}")
    
    if msg_type == "auth":
        site_key = params.get("site_key")
        user = params.get("user")
        version = params.get("version")
        
        logging.info(f"[AUTH] Client authentication request:")
        logging.info(f"[AUTH]   - site_key: {site_key}")
        logging.info(f"[AUTH]   - user: {user}")
        logging.info(f"[AUTH]   - version: {version}")
        
        # Mark as authenticated
        for conn in mining_state["connections"]:
            if conn["id"] == client_id:
                conn["authenticated"] = True
                break
        
        logging.info(f"[AUTH] Client {client_id} authenticated successfully üé∏")
        
        # Send job after auth
        await send_job(client_id)
        
        auth_response = {
            "type": "authed",
            "params": {
                "token": f"mock_token_{datetime.now().timestamp()}",
                "hashes": 0,
                "banned": False
            }
        }
        logging.info(f"[AUTH] Sending auth confirmation to {client_id}")
        return auth_response
    
    elif msg_type == "submit":
        job_id = params.get("job_id")
        nonce = params.get("nonce")
        result = params.get("result")
        version = params.get("version")
        
        logging.info(f"[HASH_RECEIVED] Client {client_id} submitted hash:")
        # logging.info(f"[HASH_RECEIVED]   - job_id: {job_id}")
        # logging.info(f"[HASH_RECEIVED]   - nonce: {nonce}")
        # logging.info(f"[HASH_RECEIVED]   - result: {result}")
        # logging.info(f"[HASH_RECEIVED]   - version: {version}")
        
        mining_state["hashes_submitted"] += 1
        logging.info(f"[HASH_RECEIVED] Total hashes received by server: {mining_state['hashes_submitted']}")
        
        # Send new job
        await send_job(client_id)
        
        submit_response = {
            "type": "hash_accepted",
            "params": {
                "hashes": mining_state["hashes_submitted"],
                "banned": False
            }
        }
        logging.info(f"[HASH_ACCEPT] Confirming hash acceptance to {client_id}")
        return submit_response
    
    elif msg_type == "verified":
        logging.info(f"[VERIFIED] Verification message from {client_id}:")
        logging.info(f"[VERIFIED] Params: {json.dumps(params, indent=2)}")
    
    else:
        logging.warning(f"[UNKNOWN] Unknown message type '{msg_type}' from {client_id}")
        logging.warning(f"[UNKNOWN] Full message: {json.dumps(data, indent=2)}")
    
    return None

async def send_job(client_id: str):
    """Send a new mining job to the client."""
    connection = next((c for c in mining_state["connections"] if c["id"] == client_id), None)
    if not connection:
        logging.warning(f"[JOB_SEND_ERROR] Connection not found for {client_id}")
        return
    
    job = {
        "type": "job",
        "params": {
            "job_id": mining_state['current_job_id'],
            "blob": f"mock_blob_data_{mining_state['current_job_id']}",
            "target": "mock_target_data",
            "algo": "cryptonight",
            "height": 1000000 + mining_state['current_job_id'],
            "seed_hash": "mock_seed_hash"
        }
    }
    
    mining_state['current_job_id'] += 1
    
    logging.info(f"[JOB_SEND] Server -> Client {client_id}")
    # logging.info(f"[JOB_SEND] Sending new mining job:")
    # logging.info(f"[JOB_SEND]   - job_id: {job['params']['job_id']}")
    # logging.info(f"[JOB_SEND]   - blob: {job['params']['blob']}")
    # logging.info(f"[JOB_SEND]   - target: {job['params']['target']}")
    # logging.info(f"[JOB_SEND]   - algo: {job['params']['algo']}")
    # logging.info(f"[JOB_SEND]   - height: {job['params']['height']}")
    # logging.info(f"[JOB_SEND]   - seed_hash: {job['params']['seed_hash']}")
    # logging.info(f"[JOB_SEND] Complete job JSON: {json.dumps(job, indent=2)}")
    
    try:
        await connection["websocket"].send_str(json.dumps(job))
        logging.info(f"[JOB_SEND_SUCCESS] Job successfully sent to {client_id}")
    except Exception as e:
        logging.error(f"[JOB_SEND_ERROR] Failed to send job to {client_id}: {e}")
        import traceback
        logging.error(f"[JOB_SEND_ERROR] Traceback: {traceback.format_exc()}")

async def handle_proxy(request):
    """Handle WebSocket upgrade for /proxy endpoint (used by CryptoMock clients)."""
    return await handle_websocket(request)

async def handle_captcha(request):
    """Mock captcha endpoint."""
    return web.Response(text="OK", content_type='text/plain')

async def handle_media(request):
    """Mock media/miner interface endpoint."""
    html = """
    <html>
    <head><title>CryptoMock Miner</title></head>
    <body>
        <h1>Mock Miner Interface</h1>
        <p>Miner endpoint active</p>
    </body>
    </html>
    """
    return web.Response(text=html, content_type='text/html')

def create_app():
    """Create aiohttp application."""
    app = web.Application()
    
    # Add routes
    app.router.add_get('/', handle_index)
    app.router.add_get('/ssl-test', handle_index)
    
    # WebSocket endpoints
    app.router.add_get('/ws', handle_websocket)
    app.router.add_get('/proxy', handle_proxy)  # Common CryptoMock endpoint
    
    # Worker scripts
    app.router.add_get('/lib/worker-asmjs.min.js', handle_worker)
    app.router.add_get('/lib/{filename}', handle_worker)  # Catch all worker requests
    
    # Additional common endpoints
    app.router.add_get('/captcha/{token}', handle_captcha)
    app.router.add_get('/media/{filename}', handle_media)
    
    return app

async def main():
    """Main server function."""
    logging.info("Starting CryptoMock Unified Server (HTTP/HTTPS + WS/WSS on same port)...")
    
    app = create_app()
    
    try:
        if USE_SSL:
            ssl_context = load_ssl_context()
            protocol = "wss or https"
        else:
            ssl_context = None
            protocol = "ws or http"
        
        # Create and start server
        runner = web.AppRunner(app)
        await runner.setup()
        
        site = web.TCPSite(
            runner, 
            SERVER_HOST, 
            SERVER_PORT,
            ssl_context=ssl_context
        )
        await site.start()
        
        logging.info(f"Server running on {protocol}://{SERVER_HOST}:{SERVER_PORT}")
        
        # Keep running
        try:
            await asyncio.Future()  # run forever
        except KeyboardInterrupt:
            logging.info("Server stopped by user")
        finally:
            await runner.cleanup()
            
    except Exception as e:
        logging.error(f"Server error: {e}")

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logging.info("Shutdown complete")
    except Exception as e:
        logging.error(f"Startup error: {e}")