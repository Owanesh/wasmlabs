import asyncio
import json
import logging
import websockets
import http.server
import socketserver
import threading
from typing import Any, Dict, Optional
from urllib.parse import urlparse, parse_qs
from datetime import datetime
import os

# SSL utilities
from https.utils import load_ssl_context

# Configura logging
from datetime import datetime
log_dir = "logs"
os.makedirs(log_dir, exist_ok=True)
timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
log_path = os.path.join(log_dir, f"{timestamp}.log")
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.FileHandler(log_path),
        logging.StreamHandler()
    ]
)

# Configurazione
HTTPS_HOST = "127.0.0.1"
HTTPS_PORT = 8000
WSS_HOST = "127.0.0.1"
WSS_PORT = 8008

# Stato globale per il mining
mining_state: Dict[str, Any] = {
    "connections": [],
    "jobs": [],
    "hashes_submitted": 0,
    "current_job_id": 1
}

class CryptoMockHTTPSHandler(http.server.BaseHTTPRequestHandler):
    """
    HTTP handler for the CryptoMock server.
    Handles GET, POST, and OPTIONS requests.
    """

    def _log_request(self) -> None:
        """
        Log details of the incoming HTTP request.
        """
        info = {
            "timestamp": datetime.now().isoformat(),
            "client": self.client_address[0],
            "method": self.command,
            "path": self.path,
            "headers": {k: v for k, v in self.headers.items()}
        }
        if "?" in self.path:
            query = parse_qs(urlparse(self.path).query)
            info["query_params"] = query
        logging.info(f"HTTPS Request: {json.dumps(info, indent=2)}")

    def do_GET(self) -> None:
        """
        Handle HTTP GET requests.
        """
        self._log_request()
        
        if self.path.startswith("/lib/"):
            # Serve worker scripts
            if "worker-asmjs.min.js" in self.path:
                self.send_response(200)
                self.send_header("Content-Type", "application/javascript")
                self.send_header("Access-Control-Allow-Origin", "*")
                self.end_headers()
                
                # Mock worker script
                worker_script = """
                // Mock CryptoMock worker
                self.onmessage = function(e) {
                    // Simulate mining work
                    var job = e.data;
                    var hashes = 0;
                    var hashesPerSecond = 100 + Math.random() * 50;
                    
                    // Simulate finding a result occasionally
                    if (Math.random() < 0.001) {
                        self.postMessage({
                            result: "mock_result_" + Math.random().toString(36).substr(2, 9),
                            job_id: job.job_id,
                            nonce: Math.floor(Math.random() * 1000000),
                            hashes: hashes,
                            hashesPerSecond: hashesPerSecond
                        });
                    } else {
                        self.postMessage({
                            hashes: hashes,
                            hashesPerSecond: hashesPerSecond
                        });
                    }
                };
                self.postMessage("ready");
                """
                self.wfile.write(worker_script.encode())
                return
                
        elif self.path.startswith("/captcha/"):
            # Mock captcha endpoint
            self.send_response(200)
            self.send_header("Content-Type", "text/html")
            self.end_headers()
            self.wfile.write(b"<html><body><h1>Mock Captcha</h1><p>Captcha verification successful</p></body></html>")
            return
            
        elif self.path.startswith("/media/"):
            # Mock media endpoint
            self.send_response(200)
            self.send_header("Content-Type", "text/html")
            self.end_headers()
            self.wfile.write(b"<html><body><h1>Mock Miner Interface</h1></body></html>")
            return
            
        else:
            # Default response
            self.send_response(200)
            self.send_header("Content-Type", "text/plain")
            self.end_headers()
            self.wfile.write(b"CryptoMock Mock Server - HTTPS Endpoint")

    def do_POST(self) -> None:
        """
        Handle HTTP POST requests.
        """
        self._log_request()
        length = int(self.headers.get("Content-Length", 0))
        body = self.rfile.read(length).decode("utf-8")
        logging.info(f"[POST] body: {body}")
        
        self.send_response(200)
        self.send_header("Content-Type", "application/json")
        self.end_headers()
        self.wfile.write(json.dumps({"status": "success", "message": "Mock POST response"}).encode())

    def do_OPTIONS(self) -> None:
        """
        Handle HTTP OPTIONS requests for CORS preflight.
        """
        # Handle CORS preflight requests
        self.send_response(200)
        self.send_header("Access-Control-Allow-Origin", "*")
        self.send_header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
        self.send_header("Access-Control-Allow-Headers", "Content-Type")
        self.end_headers()

async def handle_websocket(websocket: websockets.ServerProtocol, path: Optional[str] = None) -> None:
    """
    Handle WebSocket connections.

    Args:
        websocket: The WebSocket connection object.
        path: The path of the WebSocket connection.
    """
    client_id = f"{websocket.remote_address[0]}:{websocket.remote_address[1]}"
    logging.info(f"WebSocket connection established from {client_id}")
    
    # Add to connections list
    mining_state["connections"].append({
        "id": client_id,
        "websocket": websocket,
        "authenticated": False,
        "site_key": None
    })
    
    try:
        async for message in websocket:
            try:
                data = json.loads(message)
                logging.info(f"WebSocket message from {client_id}: {data}")
                
                response = await handle_websocket_message(data, client_id)
                if response:
                    await websocket.send(json.dumps(response))
                    
            except json.JSONDecodeError:
                logging.error(f"Invalid JSON from {client_id}: {message}")
                
    except websockets.ConnectionClosed:
        logging.info(f"WebSocket connection closed for {client_id}")
    finally:
        # Remove from connections list
        mining_state["connections"] = [c for c in mining_state["connections"] if c["id"] != client_id]

async def handle_websocket_message(data: Dict[str, Any], client_id: str) -> Optional[Dict[str, Any]]:
    """
    Process incoming WebSocket messages.

    Args:
        data: The message data received from the client.
        client_id: The identifier of the client.

    Returns:
        A response dictionary to send back to the client, if applicable.
    """
    msg_type = data.get("type")
    params = data.get("params", {})
    
    if msg_type == "auth":
        return await handle_auth(params, client_id)
    elif msg_type == "submit":
        return await handle_submit(params, client_id)
    elif msg_type == "verified":
        return await handle_verified(params, client_id)
    else:
        logging.warning(f"Unknown message type: {msg_type}")
        return None

async def handle_auth(params: Dict[str, Any], client_id: str) -> Dict[str, Any]:
    """
    Handle authentication messages from WebSocket clients.

    Args:
        params: Parameters from the authentication message.
        client_id: The identifier of the client.

    Returns:
        A dictionary containing the authentication response.
    """
    site_key = params.get("site_key")
    version = params.get("version")
    auth_type = params.get("type", "anonymous")
    
    logging.info(f"Auth request from {client_id}: site_key={site_key}, type={auth_type}")
    
    # Update connection state
    for conn in mining_state["connections"]:
        if conn["id"] == client_id:
            conn["authenticated"] = True
            conn["site_key"] = site_key
            break
    
    # Send authentication response
    response = {
        "type": "authed",
        "params": {
            "token": f"mock_token_{client_id}_{datetime.now().timestamp()}",
            "hashes": 0,
            "banned": False
        }
    }
    
    # Send initial job
    await send_job(client_id)
    
    return response

async def handle_submit(params: Dict[str, Any], client_id: str) -> Dict[str, Any]:
    """
    Handle hash submission messages from WebSocket clients.

    Args:
        params: Parameters from the submission message.
        client_id: The identifier of the client.

    Returns:
        A dictionary containing the submission response.
    """
    job_id = params.get("job_id")
    nonce = params.get("nonce")
    result = params.get("result")
    version = params.get("version")
    
    logging.info(f"Submit from {client_id}: job_id={job_id}, nonce={nonce}, result={result}")
    
    # Increment hash count
    mining_state["hashes_submitted"] += 1
    
    # Send hash accepted response
    response = {
        "type": "hash_accepted",
        "params": {
            "hashes": mining_state["hashes_submitted"],
            "banned": False
        }
    }
    
    # Send new job
    await send_job(client_id)
    
    return response

async def handle_verified(params: Dict[str, Any], client_id: str) -> None:
    """
    Handle verification messages from WebSocket clients.

    Args:
        params: Parameters from the verification message.
        client_id: The identifier of the client.
    """
    logging.info(f"Verification from {client_id}: {params}")
    return None

async def send_job(client_id: str) -> None:
    """
    Send a new mining job to the specified WebSocket client.

    Args:
        client_id: The identifier of the client.
    """
    # Find the connection
    connection = None
    for conn in mining_state["connections"]:
        if conn["id"] == client_id:
            connection = conn
            break
    
    if not connection:
        return
    
    # Create mock job
    job = {
        "type": "job",
        "params": {
            "job_id": f"mock_job_{mining_state['current_job_id']}",
            "blob": "mock_blob_data_" + str(mining_state['current_job_id']),
            "target": "mock_target_data",
            "algo": "cryptonight",
            "height": 1000000 + mining_state['current_job_id'],
            "seed_hash": "mock_seed_hash",
            "throttle": 0.0
        }
    }
    
    mining_state['current_job_id'] += 1
    
    try:
        await connection["websocket"].send(json.dumps(job))
        logging.info(f"Sent job to {client_id}: {job['params']['job_id']}")
    except websockets.ConnectionClosed:
        logging.warning(f"Connection closed while sending job to {client_id}")

def run_https_server() -> None:
    """
    Run the HTTPS server in a separate thread.
    """
    try:
        ssl_context = load_ssl_context()

        # Create server
        server = socketserver.ThreadingTCPServer((HTTPS_HOST, HTTPS_PORT), CryptoMockHTTPSHandler)
        server.socket = ssl_context.wrap_socket(server.socket, server_side=True)

        logging.info(f"HTTPS server running on https://{HTTPS_HOST}:{HTTPS_PORT}")
        server.serve_forever()

    except Exception as e:
        logging.error(f"HTTPS server error: {e}")


async def run_websocket_server() -> None:
    """
    Run the WebSocket server.
    """
    try:
        ssl_context = load_ssl_context()

        async with websockets.serve(
            handle_websocket,
            WSS_HOST,
            WSS_PORT,
            ssl=ssl_context
        ):
            logging.info(f"WSS server running on wss://{WSS_HOST}:{WSS_PORT}")
            await asyncio.Future()  # run forever

    except Exception as e:
        logging.error(f"WebSocket server error: {e}")

def main() -> None:
    """
    Main function to run both servers.
    """
    logging.info("Starting CryptoMock Mock Server...")

    # Ensure SSL certificates exist before starting servers (handled in server functions now)

    # Start HTTPS server in a separate thread
    https_thread = threading.Thread(target=run_https_server, daemon=True)
    https_thread.start()

    # Start WebSocket server in the main thread
    try:
        asyncio.run(run_websocket_server())
    except KeyboardInterrupt:
        logging.info("Server stopped by user")
    except Exception as e:
        logging.error(f"Server error: {e}")

if __name__ == "__main__":
    main()

